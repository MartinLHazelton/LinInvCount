% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/xlambda-sampler.r
\name{Xlambdasampler}
\alias{Xlambdasampler}
\title{Joint x-lambda sampler for Poisson and negative binomial linear inverse problems}
\usage{
Xlambdasampler(
  y,
  A,
  lambda.updater,
  lambda.ini,
  U = NULL,
  Method = "MH",
  Reorder = TRUE,
  tune.par = 0.5,
  combine = FALSE,
  x.order = NULL,
  x.ini = NULL,
  Model = "Poisson",
  Proposal = "Unif",
  NB.alpha.ini = 1,
  lambda.additional = NA,
  other.pars = numeric(0),
  ndraws = 10000,
  burnin = 2000,
  verbose = 0,
  THIN = 1
)
}
\arguments{
\item{y}{Matrix of sequence of observed count data vectors; each column is an observation.}

\item{A}{Model configuration matrix, assumed to be binary.}

\item{lambda.ini}{Initial mean vector for x.}

\item{U}{Optional matrix the columns of which should be a Markov (sub)-basis.}

\item{Method}{"MH" for Metropolis-Hastings sampler, "Gibbs" for Gibbs sampler.}

\item{Reorder}{Should the columns of A be reordered? Defaults to TRUE.}

\item{tune.par}{Tuning parameter (alpha) controlling variation in fitness values for lattice bases. Defaults to 0.5.}

\item{combine}{Should extra moves be included combining lattice basis vectors? Defaults to FALSE, but should usually be set to TRUE if A is not unimodular.}

\item{x.order}{If Reorder=FALSE, x.order can be used to reorder columns of A to match ordering of entries of x. Defaults to NULL when no such reordering is performed.}

\item{x.ini}{Matrix of initial values for x, with column orderings matching that for y. Default is NULL, when initial values derived through integer programming.}

\item{Model}{"Poisson" or "NegBin".}

\item{Proposal}{"NonUnif" or "Unif" (default).}

\item{NB.alpha.ini}{Initial value for dispersion parameter for negaqtive-binomial distribution. Defaults to 1.}

\item{lambda.additional}{Optional object to transfer additional information to lambda.updater.}

\item{other.pars}{Optional object to provide initial values for other model parameters.}

\item{ndraws}{Number of iterations to run sampler after burn-in. One iteration comprises cycling through the full basis (possibly augmented by a combined move). Defaults to 10^4.}

\item{burnin}{Number of iteractions for burn in period. Defaults to 2000, which is usually more than adequate.}

\item{verbose}{Controls level of detail in recording lattice bases used.}

\item{THIN}{Thinning parameter for output. Defaults to 1 (no thinning).}
}
\value{
A list with components X (an array, for which X\link{i,j,k} is the k-th sampled value of the i-th component of the j-th observation of x), LAMBDA (a matrix, each row corresponding to samples for an entry of lambda), NB.ALPHA (a vector of sampler values of NB.alpha, NA if model is Poisson), OTHER.PARS (a matrix, each row corresponding to an additional parameter; zero rows if there are none) and x.order (a vector describing dynamic selection of lattice bases, if verbose=1).
}
\description{
Consider the linear inverse problem y=Ax, where x follows a Poisson or negative binomial distribution with mean lambda = E\link{x}. This function jointly samples lambda and x.
}
\examples{
data(LondonRoad)
lu <- function(x,lambda,NB.alpha=NA,lambda.tuning=1,lambda.additional=NA) { list(lambda=rgamma(length(lambda),shape=x+0.5*LondonRoad$lambda,rate=1.5),other.pars=numeric(0),NB.alpha=NA) }
Xlambdasampler(y=LondonRoad$y,A=LondonRoad$A,lambda.updater=lu,lambda.ini=LondonRoad$lambda,Model="Poisson",Method="Gibbs",tune.par=0.5,combine=FALSE)
}
